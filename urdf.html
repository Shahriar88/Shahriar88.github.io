<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>URDF Viewer (tolerant)</title>
  <style>
    html,body{height:100%;margin:0}
    #viewport{position:fixed;inset:0}
    #ui{
      position:fixed;top:12px;left:12px;right:12px;max-width:520px;
      background:rgba(255,255,255,.88);backdrop-filter:blur(6px);
      padding:12px;border-radius:14px;box-shadow:0 6px 24px rgba(0,0,0,.15);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial
    }
    #sliders{max-height:38vh;overflow:auto;margin-top:8px}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;margin:6px 0}
    .bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px}
    .btn{padding:6px 10px;border-radius:10px;border:1px solid #ddd;background:#fff;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .muted{opacity:.75}
    #err{margin-top:8px;color:#b00020;font-size:12px;white-space:pre-wrap}
    #jvals{font-size:12px;max-height:12vh;overflow:auto;line-height:1.35}
    code{background:#f1f3f6;padding:1px 6px;border-radius:6px}
  </style>
</head>
<body>
  <canvas id="viewport"></canvas>

  <div id="ui">
    <div style="display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap">
      <h3 style="margin:0">URDF Viewer</h3>
      <div class="muted" id="fileInfo">Auto-loading: <code>assets/robot.urdf</code></div>
    </div>

    <div class="bar">
      <button class="btn" id="resetBtn" title="Fit camera to model">Reset view</button>
      <label class="btn" style="display:inline-flex;gap:6px;align-items:center">
        <input id="axisChk" type="checkbox"> Axis helper
      </label>
      <label class="btn" style="display:inline-flex;gap:6px;align-items:center">
        <input id="wireChk" type="checkbox"> Wireframe
      </label>
    </div>

    <div id="sliders"></div>

    <div id="jvals"></div>
    <div id="err"></div>
  </div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/OrbitControls.js';
  import URDFLoader from 'https://cdn.jsdelivr.net/npm/urdf-loader@0.10.3/build/URDFLoader.js';


    // ---------- Scene ----------
    const canvas = document.getElementById('viewport');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0xf6f7fb);
    const camera = new THREE.PerspectiveCamera(45, 2, 0.01, 2000); camera.position.set(2.5, 1.5, 3.5);
    const controls = new OrbitControls(camera, renderer.domElement); controls.target.set(0, 0.5, 0); controls.update();

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,5,5); scene.add(dir);
    const grid = new THREE.GridHelper(10, 20, 0x888888, 0xdddddd); scene.add(grid);
    const axisHelper = new THREE.AxesHelper(0.4); axisHelper.visible = false; scene.add(axisHelper);

    function onResize(){
      const w=innerWidth,h=innerHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix();
    }
    addEventListener('resize', onResize); onResize();

    // ---------- URDF loader ----------
    const loader = new URDFLoader();
    loader.packages = { '': 'assets/' }; // map package:// to /assets/

    let robot;
    let wireframeEnabled = false;

    function setWireframe(node, on){
      node.traverse?.(obj=>{
        if (obj.isMesh && obj.material){
          // handle Material or Array<Material>
          const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
          mats.forEach(m => { if ('wireframe' in m) m.wireframe = on; });
        }
      });
    }

    function buildSliders(){
      const wrap = document.getElementById('sliders'); wrap.innerHTML = '';
      const jvals = document.getElementById('jvals'); jvals.innerHTML = '';
      if (!robot || !robot.joints) return;

      Object.entries(robot.joints).forEach(([name, j])=>{
        if (!['revolute','continuous','prismatic'].includes(j.type)) return;
        const row = document.createElement('div'); row.className = 'row';
        const label = document.createElement('label'); label.textContent = `${name} (${j.type})`; row.appendChild(label);
        const input = document.createElement('input'); input.type = 'range';

        const lim = j.limits || { lower: -Math.PI, upper: Math.PI };
        const prism = j.type === 'prismatic';
        input.min  = prism ? (lim.lower ?? -0.1)   : (lim.lower ?? -Math.PI);
        input.max  = prism ? (lim.upper ??  0.1)   : (lim.upper ??  Math.PI);
        input.step = prism ? 0.001                 : 0.01;
        input.value = j.angle || 0;
        input.oninput = e => {
          const v = parseFloat(e.target.value);
          prism ? j.setPosition(v) : j.setJointValue(v);
          updateJointList();
        };
        row.appendChild(input); wrap.appendChild(row);
      });

      updateJointList();
    }

    function updateJointList(){
      const jvals = document.getElementById('jvals');
      if (!robot || !robot.joints){ jvals.textContent=''; return; }
      const lines = [];
      Object.entries(robot.joints).forEach(([name, j])=>{
        if (!['revolute','continuous','prismatic'].includes(j.type)) return;
        const val = (j.type === 'prismatic') ? (j.position ?? 0) : (j.angle ?? 0);
        lines.push(`${name}: ${val.toFixed(3)}`);
      });
      jvals.textContent = lines.join('\n');
    }

    function frameFit(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = Math.max(1e-3, box.getSize(new THREE.Vector3()).length());
      const c = box.getCenter(new THREE.Vector3());
      controls.target.copy(c); controls.update();
      const dist = size * 0.9;
      camera.position.copy(c).add(new THREE.Vector3(dist*0.6, dist*0.4, dist*0.8));
      camera.near = Math.max(0.001, size * 0.001);
      camera.far  = Math.max(50, size * 10);
      camera.updateProjectionMatrix();
      camera.lookAt(c);
    }

    const showErr = (m)=> document.getElementById('err').textContent = m || '';

    // ---------- Tolerant sanitizer ----------
    function sanitizeURDF(xmlText){
      if (!xmlText.trim().startsWith('<?xml')) {
        xmlText = `<?xml version="1.0"?>\n` + xmlText;
      }
      const dom = new DOMParser().parseFromString(xmlText, 'application/xml');
      const parseErr = dom.getElementsByTagName('parsererror')[0];
      if (parseErr) throw new Error('XML parse error: ' + parseErr.textContent);

      function normalizeGeom(container){
        const geo = Array.from(container.children).find(n => n.nodeName === 'geometry');
        const stray = Array.from(container.children).filter(n =>
          ['box','cylinder','sphere','mesh'].includes(n.nodeName)
        );
        if (stray.length){
          let g = geo;
          if (!g) { g = dom.createElement('geometry'); container.appendChild(g); }
          stray.forEach(s => { container.removeChild(s); g.appendChild(s); });
        }
      }
      dom.querySelectorAll('visual,collision').forEach(node => normalizeGeom(node));
      dom.querySelectorAll('joint[type="fixed"] > dynamics').forEach(d => d.parentNode.removeChild(d));
      return new XMLSerializer().serializeToString(dom);
    }

    async function loadAndRender(path){
      try{
        showErr('');
        document.getElementById('fileInfo').innerHTML = `Auto-loading: <code>${path}</code>`;
        const res = await fetch(path, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status} for ${path}`);
        const txt = await res.text();
        const sanitized = sanitizeURDF(txt);

        if (robot) { scene.remove(robot); robot = undefined; }

        loader.parse(
          sanitized,
          'assets/',
          r => {
            robot = r;
            scene.add(robot);
            setWireframe(robot, wireframeEnabled);
            frameFit(robot);
            buildSliders();
          },
          e => showErr('URDF parse error: ' + (e?.message || e))
        );
      } catch(e){
        showErr((e && e.message) ? e.message : String(e));
        console.error(e);
      }
    }

    // ---------- UI ----------
    document.getElementById('resetBtn').onclick = ()=> { if (robot) frameFit(robot); };
    document.getElementById('axisChk').onchange = e => { axisHelper.visible = e.target.checked; };
    document.getElementById('wireChk').onchange = e => {
      wireframeEnabled = e.target.checked;
      if (robot) setWireframe(robot, wireframeEnabled);
    };

    // ---------- Boot ----------
    const urlUrdf = new URLSearchParams(location.search).get('urdf');
    const defaultPath = urlUrdf || 'assets/robot.urdf';
    loadAndRender(defaultPath);

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  </script>
</body>
</html>
