<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>URDF Viewer (tolerant)</title>
  <style>
    html,body{height:100%;margin:0}
    #viewport{position:fixed;inset:0}
    #ui{
      position:fixed;top:12px;left:12px;right:12px;max-width:460px;
      background:rgba(255,255,255,.85);backdrop-filter:blur(6px);
      padding:12px;border-radius:14px;box-shadow:0 6px 24px rgba(0,0,0,.15);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial
    }
    #sliders{max-height:40vh;overflow:auto}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;margin:6px 0}
    #err{margin-top:8px;color:#b00020;font-size:12px;white-space:pre-wrap}
  </style>
</head>
<body>
  <canvas id="viewport"></canvas>
  <div id="ui">
    <h3>URDF Viewer</h3>
    <div>Auto-loading: <code>assets/robot.urdf</code></div>
    <div id="sliders"></div>
    <div id="err"></div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';
    import URDFLoader from 'https://unpkg.com/urdf-loader@0.10.3/src/URDFLoader.js';

    // --- Three.js scene ---
    const canvas = document.getElementById('viewport');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0xf6f7fb);
    const camera = new THREE.PerspectiveCamera(45, 2, 0.01, 1000); camera.position.set(2.5, 1.5, 3.5);
    const controls = new OrbitControls(camera, renderer.domElement); controls.target.set(0, 0.5, 0); controls.update();
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,5,5); scene.add(dir);
    scene.add(new THREE.GridHelper(10, 20, 0x888888, 0xdddddd));
    function onResize(){ const w=innerWidth,h=innerHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); }
    addEventListener('resize', onResize); onResize();

    // --- URDF loader ---
    const loader = new URDFLoader();
    // Map package:// URIs (if present) to /assets/
    loader.packages = { '': 'assets/' };

    let robot;
    function buildSliders(){
      const wrap = document.getElementById('sliders'); wrap.innerHTML = '';
      if (!robot || !robot.joints) return;
      Object.entries(robot.joints).forEach(([name, j])=>{
        if (!['revolute','continuous','prismatic'].includes(j.type)) return;
        const row = document.createElement('div'); row.className = 'row';
        const label = document.createElement('label'); label.textContent = `${name} (${j.type})`; row.appendChild(label);
        const input = document.createElement('input'); input.type = 'range';
        const lim = j.limits || { lower: -Math.PI, upper: Math.PI };
        const prism = j.type === 'prismatic';
        input.min  = prism ? (lim.lower ?? -0.1)   : (lim.lower ?? -Math.PI);
        input.max  = prism ? (lim.upper ??  0.1)   : (lim.upper ??  Math.PI);
        input.step = prism ? 0.001                 : 0.01;
        input.value = j.angle || 0;
        input.oninput = e => { const v = parseFloat(e.target.value); prism ? j.setPosition(v) : j.setJointValue(v); };
        row.appendChild(input); wrap.appendChild(row);
      });
    }

    function frameFit(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = Math.max(1e-3, box.getSize(new THREE.Vector3()).length());
      const c = box.getCenter(new THREE.Vector3());
      controls.target.copy(c); controls.update();
      camera.position.copy(c).add(new THREE.Vector3(size*0.6, size*0.4, size*0.8));
      camera.lookAt(c);
    }

    const showErr = (m)=> document.getElementById('err').textContent = m || '';

    // --- Tolerant parser: fix common URDF quirks before feeding to URDFLoader ---
    function sanitizeURDF(xmlText){
      // ensure xml decl (optional)
      if (!xmlText.trim().startsWith('<?xml')) {
        xmlText = `<?xml version="1.0"?>\n` + xmlText;
      }
      const dom = new DOMParser().parseFromString(xmlText, 'application/xml');
      const parseErr = dom.getElementsByTagName('parsererror')[0];
      if (parseErr) throw new Error('XML parse error: ' + parseErr.textContent);

      // Helper: ensure exactly one <geometry> under <visual>/<collision>.
      function normalizeGeom(container){
        const geo = Array.from(container.children).find(n => n.nodeName === 'geometry');
        // Collect any primitive siblings not inside geometry
        const stray = Array.from(container.children).filter(n =>
          ['box','cylinder','sphere','mesh'].includes(n.nodeName)
        );
        if (stray.length){
          let g = geo;
          if (!g) { g = dom.createElement('geometry'); container.appendChild(g); }
          stray.forEach(s => { container.removeChild(s); g.appendChild(s); });
        }
      }

      // Fix <visual> and <collision> blocks throughout
      ['visual','collision'].forEach(tag=>{
        dom.querySelectorAll(tag).forEach(node => normalizeGeom(node));
      });

      // Optional: remove <dynamics> on fixed joints (safer for strict parsers)
      dom.querySelectorAll('joint[type="fixed"] > dynamics').forEach(d => d.parentNode.removeChild(d));

      // Serialize back to text
      return new XMLSerializer().serializeToString(dom);
    }

    async function loadAndRender(path){
      try{
        showErr('');
        const res = await fetch(path, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status} for ${path}`);
        const txt = await res.text();
        const sanitized = sanitizeURDF(txt);

        if (robot) scene.remove(robot);

        // Use URDFLoader.parse to feed the sanitized string
        loader.parse(
          sanitized,
          'assets/',                  // resource path for package://
          r => { robot = r; scene.add(robot); frameFit(robot); buildSliders(); },
          e => showErr('URDF parse error: ' + (e?.message || e))
        );
      } catch(e){
        showErr((e && e.message) ? e.message : String(e));
        console.error(e);
      }
    }

    // Auto-load your file
    loadAndRender('assets/robot.urdf');

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  </script>
</body>
</html>
