<!-- File: public/index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>URDF + Three.js Viewer</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      html, body { height: 100%; margin: 0; background:#f5f7fa; }
      canvas { display: block; }
      .error {
        position: fixed; top: 12px; left: 12px; z-index: 10;
        padding: 8px 10px; border-radius: 10px;
        background: #fff3f3; color: #b00020; border: 1px solid #ffd2d2;
        font: 12px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        max-width: 70ch; white-space: pre-wrap;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
          "urdf-loader": "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/dist/URDFLoader.js"
        }
      }
    </script>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import * as URDFModule from "urdf-loader"; // supports both named/default export

      // Resolve class regardless of CDN's export shape
      const URDFLoader = URDFModule.URDFLoader ?? URDFModule.default;

      // --- Renderer ----------------------------------------------------------
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace; // WHY: correct colors
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // --- Scene / Camera / Controls ----------------------------------------
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf5f7fa);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000);
      camera.position.set(2.5, 2.0, 3.0);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // --- Lighting ----------------------------------------------------------
      scene.add(new THREE.AmbientLight(0xffffff, 0.55));
      const key = new THREE.DirectionalLight(0xffffff, 1.1);
      key.position.set(5, 8, 6);
      key.castShadow = true; // WHY: improves perception of shape
      key.shadow.mapSize.set(2048, 2048);
      scene.add(key);

      // --- Ground / Grid -----------------------------------------------------
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 1, metalness: 0 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const grid = new THREE.GridHelper(10, 20);
      grid.position.y = 0.001;
      scene.add(grid);

      // --- URDF Loader -------------------------------------------------------
      const loader = new URDFLoader();
      loader.fetchOptions = { mode: "cors" };
      // Map relative URIs and package:// URIs (adjust to your layout)
      loader.packages = {
        "": "assets/",                        // relative URIs inside URDF
        "my_robot_package": "assets/my_robot_package/" // package://my_robot_package/...
      };

      // Robust mesh loader for GLB/GLTF, DAE, STL
      loader.loadMeshCb = async (meshPath, manager, onComplete) => {
        try {
          const url = meshPath;
          const ext = url.split("?")[0].split("#")[0].split(".").pop()?.toLowerCase();

          if (ext === "glb" || ext === "gltf") {
            const { GLTFLoader } = await import("three/addons/loaders/GLTFLoader.js");
            const gltfLoader = new GLTFLoader(manager);
            gltfLoader.load(url, (gltf) => {
              const obj = gltf.scene || gltf.scenes?.[0];
              if (obj) onComplete(obj); else onComplete(null);
            }, undefined, () => onComplete(null));
            return;
          }

          if (ext === "dae") {
            const { ColladaLoader } = await import("three/addons/loaders/ColladaLoader.js");
            const daeLoader = new ColladaLoader(manager);
            daeLoader.load(url, (collada) => onComplete(collada.scene || null), undefined, () => onComplete(null));
            return;
          }

          if (ext === "stl") {
            const { STLLoader } = await import("three/addons/loaders/STLLoader.js");
            const stlLoader = new STLLoader(manager);
            stlLoader.load(url, (geom) => {
              const mat = new THREE.MeshStandardMaterial({ color: 0x9a9a9a, roughness: 0.85, metalness: 0.05 });
              const mesh = new THREE.Mesh(geom, mat);
              onComplete(mesh);
            }, undefined, () => onComplete(null));
            return;
          }

          // Fallback: let default loader try (or fail gracefully)
          onComplete(null);
        } catch (e) {
          console.warn("Mesh load error:", meshPath, e);
          onComplete(null);
        }
      };

      let robot = null;

      loader.load(
        "assets/robot.urdf",
        (model) => {
          robot = model;

          // Convert from Z-up (URDF) to Y-up (Three)
          robot.rotation.x = -Math.PI / 2;

          robot.traverse((o) => {
            if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; }
          });

          scene.add(robot);
          frameObject(robot, camera, controls);
        },
        // progress
        (xhr) => {
          // console.log("URDF progress", xhr.loaded, "/", xhr.total);
        },
        (err) => showError(`URDF load error: ${err?.message || err}`)
      );

      // --- Utilities ---------------------------------------------------------
      function frameObject(object3D, cam, ctrls) {
        const box = new THREE.Box3().setFromObject(object3D);
        if (!isFinite(box.min.x) || !isFinite(box.max.x)) return;

        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        const maxDim = Math.max(size.x, size.y, size.z);
        const fitHeight = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(cam.fov) / 2));
        const fitWidth  = fitHeight / cam.aspect;
        const distance = 1.25 * Math.max(fitHeight, fitWidth);

        const dir = new THREE.Vector3(1, 0.6, 1).normalize();
        cam.position.copy(center).addScaledVector(dir, distance);
        cam.near = Math.m
