<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>URDF Loader</title>
  <style>
    /* Tiny HUD to tweak position */
    #hud {
      position: fixed; top: 10px; left: 10px; z-index: 10;
      background: rgba(255,255,255,0.9); border: 1px solid #ddd; border-radius: 8px;
      padding: 8px 10px; font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    #hud label { display: grid; grid-template-columns: 16px 1fr 42px; gap: 6px; align-items: center; margin: 6px 0; }
    #hud input[type="range"] { width: 200px; }
    #hud input[type="number"] { width: 42px; }
  </style>
</head>
<body>
  <!-- Minimal position controls -->
  <div id="hud">
    <label> X
      <input id="posX" type="range" min="-5" max="5" step="0.01" value="0">
      <input id="numX" type="number" step="0.01" value="0">
    </label>
    <label> Y
      <input id="posY" type="range" min="-5" max="5" step="0.01" value="0">
      <input id="numY" type="number" step="0.01" value="0">
    </label>
    <label> Z
      <input id="posZ" type="range" min="-5" max="5" step="0.01" value="0">
      <input id="numZ" type="number" step="0.01" value="0">
    </label>
    <div style="margin-top:6px;color:#555">Keyboard: ← → (X), ↑ ↓ (Z), Q/E (Y)</div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';
    import URDFLoader from './urdf_js/URDFLoader.js';
    import { createJointSliders } from './urdf_js/urdf_joint_sliders.js';
    import { OrbitControls } from './urdf_js/OrbitControls.js';

    // --- Config: change these to set the initial placement ---
    const INITIAL_POS = { x: -0.31, y: -0.09, z: -0.58 };

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeeeeee);

    // Camera
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(1, 1, 1);
    camera.lookAt(0, 0, 0);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(3, 3, 3);
    scene.add(directionalLight);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // --- URDF + minimal position controls -----------------------------------
    const manager = new THREE.LoadingManager();
    const loader = new URDFLoader(manager);
    loader.parseVisual = true;
    loader.parseCollision = false;

    let robot = null;

    loader.load(
      'assets/robot2.urdf',
      loaded => {
        robot = loaded;
        // Set initial placement BEFORE syncing HUD (so sliders match).
        robot.position.set(INITIAL_POS.x, INITIAL_POS.y, INITIAL_POS.z); // WHY: defines start XYZ
        scene.add(robot);

        // Initialize HUD values based on current robot.position
        syncHUDFromRobot();

        // Optional: joint sliders you already had
        createJointSliders(robot);
      },
      undefined,
      error => console.error('Failed to load URDF:', error)
    );

    // HUD elements
    const posX = document.getElementById('posX');
    const posY = document.getElementById('posY');
    const posZ = document.getElementById('posZ');
    const numX = document.getElementById('numX');
    const numY = document.getElementById('numY');
    const numZ = document.getElementById('numZ');

    // Keep sliders and numbers in sync
    function linkPair(rangeEl, numEl, onChange) {
      const sync = (val) => { rangeEl.value = val; numEl.value = val; onChange(parseFloat(val)); };
      rangeEl.addEventListener('input', e => sync(e.target.value));
      numEl.addEventListener('input',  e => sync(e.target.value));
      return (val) => sync(val);
    }

    const setX = linkPair(posX, numX, (v) => { if (robot) robot.position.x = v; });
    const setY = linkPair(posY, numY, (v) => { if (robot) robot.position.y = v; });
    const setZ = linkPair(posZ, numZ, (v) => { if (robot) robot.position.z = v; });

    function syncHUDFromRobot() {
      if (!robot) return;
      setX(robot.position.x.toFixed(2));
      setY(robot.position.y.toFixed(2));
      setZ(robot.position.z.toFixed(2));
    }

    // Keyboard nudges (Shift = bigger step)
    window.addEventListener('keydown', (e) => {
      if (!robot) return;
      const step = e.shiftKey ? 0.5 : 0.05;
      let changed = false;
      switch (e.key) {
        case 'ArrowLeft':  robot.position.x -= step; changed = true; break;
        case 'ArrowRight': robot.position.x += step; changed = true; break;
        case 'ArrowUp':    robot.position.z -= step; changed = true; break;
        case 'ArrowDown':  robot.position.z += step; changed = true; break;
        case 'q': case 'Q': robot.position.y += step; changed = true; break;
        case 'e': case 'E': robot.position.y -= step; changed = true; break;
      }
      if (changed) syncHUDFromRobot();
    });

    // Programmatic helper if you want it elsewhere
    window.moveRobotTo = (x, y, z) => {
      if (!robot) return;
      robot.position.set(x, y, z);
      syncHUDFromRobot();
    };
  </script>
</body>
</html>
