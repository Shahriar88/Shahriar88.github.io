// Generated by CoffeeScript 2.7.0
(function() {
  // Main object definitions
  // =====================
  // We base whole program on Backbone.js. Each part is a model, as well as joints.

  // I tried  so that all robot parts ware  in App namespace
  var ref, ref1, ref2, ref3, ref4,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  window.App = window.App || {};

  App.el2array = function(el, def = "0 0 0", check = true, delim = " ") { //returns array of numbers or default array from string
    var arrayw, el2array;
    el2array = (check && el) || def;
    arrayw = el2array.split(delim);
    arrayw = _.map(arrayw, function(num) {
      return num * 1;
    });
    return arrayw;
  };

  App.Router = (function() {
    // Class responsible for changing addresses in browser
    class Router extends Backbone.Router {
      change_robot(id) {
        App.currentrobot.id = id;
        return App.currentrobot.fetch();
      }

      new_robot() {
        return delete App.currentrobot.id;
      }

    };

    Router.prototype.routes = {
      "new_robot": "new_robot",
      ":id": "change_robot"
    };

    return Router;

  }).call(this);

  // Model of robot joint, it is responsible of moving links: connecting them together with parent-child relation, as well as moving with controlls/ animation
  ref = App.RobotJoint = class RobotJoint extends Backbone.Model {
    constructor() {
      super(...arguments);
      this.jointogether = this.jointogether.bind(this);
      // Method to change joint theta value and in process move child link. It changes current value or child matrix and upgrades value of this.theta.
      // t1 - joint value
      // t2 - will be used when planar joint is implemented
      // When movement is impossible, return false
      this.movejoint = this.movejoint.bind(this);
      this.jointval = this.jointval.bind(this);
    }

    initialize() {
      var axis, basicMatrix, position, rotation;
      this.theta = 0;
      this.name = this.attributes.name;
      axis = App.el2array(_.has(this.attributes, "axis") && this.attributes.axis.xyz, "1 0 0");
      this.axis = new THREE.Vector3(axis[0], axis[1], axis[2]);
      rotation = App.el2array(_.has(this.attributes, "origin") && this.attributes.origin.rpy, "0 0 0");
      this.basicrotation = new THREE.Euler(rotation[0], rotation[1], rotation[2]);
      position = App.el2array(_.has(this.attributes, "origin") && this.attributes.origin.xyz, "0 0 0");
      this.basicposition = new THREE.Vector3(position[0], position[1], position[2]);
      this.lower = (_.has(this.attributes, "limit") && this.attributes.limit.lower) || -Math.PI; // could be -Infinity
      this.upper = (_.has(this.attributes, "limit") && this.attributes.limit.upper) || Math.PI; //could be Infinity
      this.lower = this.lower * 1;
      this.upper = this.upper * 1;
      basicMatrix = new THREE.Matrix4();
      this.movementMatrix = new THREE.Matrix4();
      basicMatrix.makeRotationFromEuler(this.basicrotation);
      basicMatrix.setPosition(this.basicposition);
      this.basicMatrix = basicMatrix;
      this.currentMatrix = new THREE.Matrix4();
      this.type = this.attributes.type;
      this.on("change:linkcollection", this.jointogether);
      return this;
    }

    jointogether() { //if possible, we make connection between two 3d link objects
      var child, parent;
      boundMethodCheck(this, ref);
      if (_.has(this.attributes, "parent") && _.has(this.attributes, "child") && _.has(this.attributes, "linkcollection")) {
        child = this.get("linkcollection").get(this.attributes.child.link);
        parent = this.get("linkcollection").get(this.attributes.parent.link);
        this.parentobject3d = parent.get("link");
        this.childobject3d = child.get("link");
        this.parentobject3d.add(this.childobject3d);
        this.childobject3d.matrixAutoUpdate = false;
        return this.childobject3d.matrix = this.basicMatrix;
      }
    }

    movejoint(t1, t2) { //TODO planar type
      var tempMatrix, tempaxis;
      boundMethodCheck(this, ref);
      t1 = t1 != null ? t1 : this.theta;
      tempMatrix = new THREE.Matrix4();
      tempaxis = new THREE.Vector3().copy(this.axis);
      if ((this.upper != null) && (this.lower != null)) {
        t1 = Math.max(this.lower, Math.min(t1, this.upper));
      }
      if (this.type === "continuous" || ((this.upper >= t1 && t1 >= this.lower))) { //check whether movement is allowed
        switch (this.type) {
          case "revolute":
            this.movementMatrix = tempMatrix.makeRotationAxis(this.axis, t1);
            break;
          case "continuous":
            this.movementMatrix = tempMatrix.makeRotationAxis(this.axis, t1);
            break;
          case "prismatic":
            this.movementMatrix = tempMatrix.setPosition(tempaxis.multiplyScalar(t1));
            break;
          case "fixed":
            this.movementMatrix.identity();
            break;
          case "planar":
            this.movementMatrix.identity(); //TODO
        }
        this.theta = t1; //set current state of joint
// if not between upper and lower, do not move, return that movejoint failed
      } else {
        this.movementMatrix.identity();
        return false;
      }
      this.currentMatrix.multiplyMatrices(this.basicMatrix, this.movementMatrix);
      this.childobject3d.matrix = this.currentMatrix;
      return this;
    }

    jointval() { //just an interface
      boundMethodCheck(this, ref);
      return this.theta;
    }

  };

  // Helper for implementing true modulo operator
  window.true_mod = function(x, m) {
    return (x % m + m) % m;
  };

  // RobotTrajectory is a class to  that remembers how some particular link of robot moved
  ref1 = App.RobotTrajectory = class RobotTrajectory extends Backbone.Model {
    constructor() {
      super(...arguments);
      this.new_name = this.new_name.bind(this);
      this.add_to_trajectory = this.add_to_trajectory.bind(this);
      this.clear_trajectory = this.clear_trajectory.bind(this);
    }

    initialize(name) {
      var i, j, material, ref2;
      this.trajectory = new THREE.Shape();
      this.link_name = this.attributes.name;
      this.allpoints = new THREE.Geometry();
      this.N = 1000;
      for (i = j = 0, ref2 = this.N; j <= ref2; i = j += 1) {
        this.allpoints.vertices.push(new THREE.Vector3(0.0, 0.0, 1.0));
      }
      this.n = 0;
      //@allvertices=[]
      this.throttled_add_to_trajectory = _.throttle(this.add_to_trajectory, 20); //will add min 50ms aside
      material = new THREE.LineBasicMaterial({
        color: 0xff0000,
        linewidth: 3
      });
      this.line = new THREE.Line(this.allpoints, material);
      //allpoints=[]
      window.scene.add(this.line);
      return true;
    }

    new_name(name) {
      boundMethodCheck(this, ref1);
      this.attributes.name = name;
      this.link_name = name;
      this.clear_trajectory();
      return true;
    }

    add_to_trajectory() {
      var diff, error, j, lastvector, len, matrix, newpoint, numbers, ref2, ref3;
      boundMethodCheck(this, ref1);
      try {
        matrix = window.robotlinkcollection.get(this.link_name).get("link").matrixWorld.elements; //TODO maybe only once?
        //console.log(matrix)
        newpoint = new THREE.Vector3(matrix[12], matrix[13], matrix[14]);
        // Not adding points that are very near
        len = 1000;
        //if(@allvertices.length>0)
        lastvector = this.allpoints.vertices[true_mod(this.n - 1, this.N)];
        diff = new THREE.Vector3();
        diff.subVectors(newpoint, lastvector);
        len = diff.length();
        if (len > 0.0001) { //when SI this would mean one thenth of mm
          
          //@allpoints=new THREE.Geometry()
          //number=true_mod(@n,@N)
          if (this.n < this.N) {
            this.allpoints.vertices[this.n] = newpoint;
//this will run only in first N iterations ;)
            for (numbers = j = ref2 = this.n, ref3 = this.N; j <= ref3; numbers = j += 1) {
              this.allpoints.vertices[numbers] = newpoint;
            }
          } else {
            this.allpoints.vertices.shift(); //deleting first element
            this.allpoints.vertices.push(newpoint);
          }
          this.allpoints.verticesNeedUpdate = true;
          this.allpoints.elementsNeedUpdate = true;
          this.n++;
        } else {
          return false;
        }
      } catch (error1) {
        error = error1;
        console.log("couldn't find link:" + name);
        console.log(error);
      }
      return false;
    }

    clear_trajectory() {
      var i, j, ref2;
      boundMethodCheck(this, ref1);
      for (i = j = 0, ref2 = this.N; j <= ref2; i = j += 1) {
        this.allpoints.vertices[i].set(0, 0, 0);
      }
      this.allpoints.verticesNeedUpdate = true;
      this.allpoints.elementsNeedUpdate = true;
      return this.n = 0;
    }

  };

  ref2 = App.RobotLink = class RobotLink extends Backbone.Model {
    constructor() {
      super(...arguments);
      this.clearthislink = this.clearthislink.bind(this);
    }

    initialize() {
      var j, len1, link, mesh, ref3;
      this.robotBaseMaterial = new THREE.MeshPhongMaterial({
        color: 0x6E23BB,
        specular: 0x6E23BB,
        shininess: 10
      });
      this.id = this.get("name");
      this.meshvis_array = [];
      this.makeobject3d();
      link = new THREE.Object3D();
      link.name = this.get("name");
      ref3 = this.meshvis_array;
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        mesh = ref3[j];
        //link.add(@meshvis)
        link.add(mesh);
      }
      this.set("link", link);
      return this;
    }

    makeobject3d() {
      var boxsize, color, j, len1, length, meshvis, meshvis_array, orientation, position, radius, ref3, robotBaseMaterial, vis_no, visual_element;
      if (_.has(this.attributes, "visual")) {
        if (!Array.isArray(this.attributes.visual)) { //we make sure that visual is an array
          this.attributes.visual = [this.attributes.visual];
        }
        meshvis_array = [];
        ref3 = this.attributes.visual;
        for (vis_no = j = 0, len1 = ref3.length; j < len1; vis_no = ++j) {
          visual_element = ref3[vis_no];
          robotBaseMaterial = this.robotBaseMaterial;
          if (_.has(visual_element, "material")) {
            color = this.get("materialcollection").get(visual_element.material.name).get("color");
            robotBaseMaterial.color = color;
            robotBaseMaterial.specular = color;
          }
          //@robotBaseMaterial.color=color;
          if (_.has(visual_element.geometry, "box")) {
            boxsize = App.el2array(visual_element.geometry.box.size, "0 0 0");
            meshvis = this.makebox(boxsize, robotBaseMaterial);
          } else if (_.has(visual_element.geometry, "cylinder")) {
            length = visual_element.geometry.cylinder.length || 0;
            radius = visual_element.geometry.cylinder.radius || 0;
            meshvis = this.makecylinder(length, radius, robotBaseMaterial);
          } else if (_.has(visual_element.geometry, "sphere")) {
            radius = visual_element.geometry.sphere.radius || 0;
            meshvis = this.makesphere(radius, robotBaseMaterial);
          } else {
            meshvis = this.makeempty();
          }
          position = App.el2array(_.has(visual_element, "origin") && visual_element.origin.xyz, "0 0 0");
          orientation = App.el2array(_.has(visual_element, "origin") && visual_element.origin.rpy, "0 0 0");
          meshvis.position.set(position[0], position[1], position[2]);
          meshvis.setRotationFromEuler(new THREE.Euler(orientation[0], orientation[1], orientation[2]));
          meshvis_array.push(meshvis);
        }
      } else {
        console.log("there are no visual attributes");
        meshvis = this.makeempty();
        meshvis_array = [meshvis];
      }
      this.meshvis_array = meshvis_array;
      return this;
    }

    makecylinder(length, radius, material) {
      var meshvis, meshvis_parent;
      meshvis = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length, 500, 1), material);
      meshvis.setRotationFromEuler(new THREE.Euler(Math.PI / 2, 0.0, 0.0, 'XYZ'));
      //console.log(meshvis.rotation);
      meshvis_parent = new THREE.Mesh();
      meshvis_parent.add(meshvis);
      return meshvis_parent;
    }

    makebox(boxsize, material) {
      var meshvis;
      meshvis = new THREE.Mesh(new THREE.CubeGeometry(boxsize[0] * 1, boxsize[1] * 1, boxsize[2] * 1), material);
      return meshvis;
    }

    makesphere(radius, material) {
      var meshvis;
      meshvis = new THREE.Mesh(new THREE.SphereGeometry(radius, 20, 20), material);
      return meshvis;
    }

    makeempty() {
      var meshvis;
      meshvis = new THREE.Mesh();
      return meshvis;
    }

    clearthislink() {
      boundMethodCheck(this, ref2);
      return this.destroy();
    }

  };

  App.RobotMaterial = class RobotMaterial extends Backbone.Model {
    initialize() {
      var check, def, rgba;
      this.id = this.get("name");
      //color rgba
      if (_.has(this.attributes, "color")) {
        rgba = App.el2array(_.has(this.attributes.color, "rgba") && this.attributes.color.rgba, def = "0 0 0 1", check = true);
        this.set("color", new THREE.Color().setRGB(rgba[0], rgba[1], rgba[2]));
      }
      return this;
    }

  };

  App.RobotMaterialCollection = (function() {
    class RobotMaterialCollection extends Backbone.Collection {};

    RobotMaterialCollection.prototype.model = App.RobotMaterial;

    return RobotMaterialCollection;

  }).call(this);

  App.RobotLinkCollection = (function() {
    class RobotLinkCollection extends Backbone.Collection {};

    RobotLinkCollection.prototype.model = App.RobotLink;

    return RobotLinkCollection;

  }).call(this);

  App.RobotJointCollection = (function() {
    class RobotJointCollection extends Backbone.Collection {};

    RobotJointCollection.prototype.model = App.RobotJoint;

    return RobotJointCollection;

  }).call(this);

  App.RobotJointManipAll = (function() {
    // Controller/view for joints. It also manages the views. To init it has to have an of joints, which it will internally keep as *joints* . Gui elements for each miniview are keept in dict jointsdict
    class RobotJointManipAll extends Backbone.View {
      initialize() {
        //console.log(@options.gui)
        this.gui = this.options.gui || new dat.GUI();
        this.joints = this.options.joints;
        this.anglesfolder = this.gui.addFolder("Joint values");
        this.add2gui = this.add2gui.bind(this);
        return this.joints.each((joint) => {
          return this.add2gui(joint);
        });
      }

      add2gui(joint) {
        return this.jointsdict[joint.get("name")] = new App.RobotJointManipSingle({
          joint: joint,
          gui: this.anglesfolder
        });
      }

      // The idea behind changepose is: you provide two arrays, and it iterates through using names
      changepose(posearray, namesarray) {
        var index, j, len1, name;
        if (posearray.length !== namesarray.length) {
          console.log("pose and namearray have different lengths");
          return false;
        }
        for (index = j = 0, len1 = namesarray.length; j < len1; index = ++j) {
          name = namesarray[index];
          this.changejointval(name, posearray[index]);
        }
        return this;
      }

      changejointval(name, value) {
        this.jointsdict[name].changeval(value, true);
        return this;
      }

      // *jointsval* Method that returns values of selected joints as array. When names is empty, it will give values of all joints and all names.
      // This is so that it can be used to generate CSV of joint poses.
      // Returns array array[0] joint values array[1] joint names
      jointsval(names) {
        var movable, values;
        if (!(names != null) || names === "" || names.length === 0) { //empty or not specified
          movable = this.joints.filter(function(joint) {
            return joint.type !== "fixed";
          });
          names = _.pluck(movable, "name");
        }
        //names=_.map(@jointsdict,(value,key) ->
        //        return key
        //, @)
        values = _.map(names, function(name) {
          return this.jointsdict[name].jointval();
        }, this);
        return [values, names];
      }

    };

    RobotJointManipAll.prototype.el = $("#menu");

    RobotJointManipAll.prototype.jointsdict = {}; //TODO this name is rather bad

    return RobotJointManipAll;

  }).call(this);

  App.AllRobots = (function() {
    class AllRobots extends Backbone.Collection {};

    AllRobots.prototype.model = App.RobotURDF;

    return AllRobots;

  }).call(this);

  App.AllCSVs = class AllCSVs extends Backbone.Collection {};

  // RobotURDF is a true Backbone Model, communicating with App Engine Server
  // There can be only one such model on scene ###TODO this seems fundamentaly wrong
  App.RobotURDF = class RobotURDF extends Backbone.Model {
    initialize() {
      this.on("change", this.change_address);
      return true;
    }

    change_address() {
      return App.router.navigate("/" + this.id);
    }

  };

  App.RobotJointManipSingle = class RobotJointManipSingle extends Backbone.View {
    initialize() {
      //console.log("intialize robotjointmanipsingle");
      this.changeval = this.changeval.bind(this);
      this.jointval = this.jointval.bind(this);
      this.joint = this.options.joint;
      this.gui = this.options.gui;
      this.dummy = {};
      this.dummy["val"] = 0.01;
      if (this.joint.type !== "fixed") {
        this.controller = this.gui.add(this.dummy, 'val', this.joint.lower, this.joint.upper, 0.01).name(this.joint.get("name"));
        this.dummy["val"] = 0;
        this.controller.updateDisplay();
        return this.controller.onChange(this.changeval);
      }
    }

    // *changeval* is method to control joint from this object, if updateController is false it will just use movejoint method. Otherwise, it will also update the state of slider and state of itself - this is used when this method is accessed from the outside, not from onChange event.
    // Checks about validity of movement are made inside @joint, we just check whether it succeeded
    changeval(value, updateController = false) {
      //if (@joint.upper >= value >= @joint.lower)
      if (this.joint.movejoint(value)) {
        this.dummy["val"] = value;
        if (updateController) {
          this.dummy["val"] = value;
          this.controller.updateDisplay();
        }
      } else {
        console.log(this.joint.get("name") + " not between min max"); //TODO change it to some pretty alert visable to user
      }
      return this;
    }

    // *jointval* Giving the current value of joint, using the occasion to set it right when it is not ;)
    jointval() {
      var jointv;
      jointv = this.joint.jointval();
      if ((this.dummy["val"] = !jointv)) {
        this.dummy["val"] = jointv;
        this.controller.updateDisplay();
      }
      //@controller.updateDisplay()
      return jointv;
    }

  };

  //                console.log( "new value" + value)

  // Currently this function just tries to reset all. Robot, jointcollection, modelcollection
  // It does not change params of scene. TODO: soft reset, that is draw robot from new URDF but change just what changed, not all. Especially don't change pose.
  window.clearall = function(scene, robot, jointcollection, modelcollection) {
    scene.remove(robot);
    //jointcollection.each( (joint) -> joint.destroy())
    jointcollection.reset();
    //modelcollection.each( (link) -> link.destroy())
    return modelcollection.reset();
  };

  // Functions connected to top form, where URDF is placed. TODO: it schouldn't reset all if not asked, just update. This will make it more interactive.
  ref3 = App.RobotForm = (function() {
    class RobotForm extends Backbone.View {
      constructor() {
        super(...arguments);
        this.URDFfiledrag = this.URDFfiledrag.bind(this);
        this.URDFfiledrop = this.URDFfiledrop.bind(this);
        this.changeURDFval = this.changeURDFval.bind(this);
        this.closeScreenshot = this.closeScreenshot.bind(this);
        // Simple camera views, for fast setting
        this.frontView = this.frontView.bind(this);
        this.topView = this.topView.bind(this);
        this.sideView = this.sideView.bind(this);
      }

      //"click .robotlink": "changeURDF"
      initialize() {
        $(".robotlink").on("click", this.changeURDF);
        this.listenTo(this.model, "change", this.newRobot);
        return this.myCodeMirror = CodeMirror.fromTextArea($("#robottext")[0], {
          mode: "text/html",
          lineNumbers: true,
          theme: "ambiance"
        });
      }

      URDFfiledrag(evt) {
        boundMethodCheck(this, ref3);
        evt.stopPropagation();
        evt.preventDefault();
        return evt.originalEvent.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
      }

      URDFfiledrop(evt) {
        var f, files, j, len1, output, reader, results;
        boundMethodCheck(this, ref3);
        //window.evt=evt
        //console.log(evt)
        evt.stopPropagation();
        evt.preventDefault();
        files = evt.originalEvent.dataTransfer.files;
        output = [];
        reader = new FileReader();
        reader.onload = (event) => {
          this.myCodeMirror.setValue(event.target.result);
          this.myCodeMirror.save();
          //$("#robottext").val(event.target.result)
          return this.resetNload();
        };
        results = [];
        for (j = 0, len1 = files.length; j < len1; j++) {
          f = files[j];
          results.push(reader.readAsText(f));
        }
        return results;
      }

      visible() {
        return this.model.set({
          "visible": $('#visible').prop('checked')
        });
      }

      saveRobot() {
        this.resetNload();
        return this.model.save();
      }

      arMode() {
        var pageid, qrcode;
        pageid = App.currentrobot.id;
        qrcode = new QRCode(document.getElementById("qrcode"), {
          text: "https://mymodelrobot.appspot.com/ar/" + pageid,
          width: 128,
          height: 128,
          colorDark: "#000000",
          colorLight: "#ffffff",
          correctLevel: QRCode.CorrectLevel.H
        });
        return window.open("https://mymodelrobot.appspot.com/ar/" + pageid, "_blank");
      }

      newRobot() {
        //console.log("robot changed")
        if (window.robotlinkcollection != null) {
          window.clearall(window.scene, window.robot, window.robotjointcollection, window.robotlinkcollection);
        }
        if (window.parseRobot(this.model.attributes.urdf)) {
          App.setupGui();
          App.animate();
          this.myCodeMirror.setValue(this.model.attributes.urdf);
          this.myCodeMirror.save();
          return $('#visible').prop('checked', this.model.attributes.visible);
        } else {
          return window.alert("there was something wrong with your URDF");
        }
      }

      resetNload() {
        var urdffromform;
        this.myCodeMirror.save(); //this pushes the codemirror code to textarea (robottext)
        urdffromform = $(this.el).find("#robottext").val();
        return this.model.set({
          urdf: urdffromform
        });
      }

      changeURDF(event) {
        var linkval;
        event.preventDefault();
        linkval = $(this).attr("href");
        $.get(linkval, App.forumula.changeURDFval);
        return true;
      }

      changeURDFval(xmlval) {
        var textval;
        boundMethodCheck(this, ref3);
        textval = (new XMLSerializer()).serializeToString(xmlval);
        this.myCodeMirror.setValue(textval);
        this.myCodeMirror.save();
        //$("#robottext").val(textval)
        return true;
      }

      showScreenshot() {
        var img1;
        App.render();
        img1 = window.renderer.domElement.toDataURL("image/png");
        $("#screenshotplace").html('<img src="' + img1 + '"/>');
        return $("#screenshottext").text("Click image to close");
      }

      closeScreenshot() {
        boundMethodCheck(this, ref3);
        $("#screenshotplace").html('');
        return $("#screenshottext").text("");
      }

      frontView() {
        boundMethodCheck(this, ref3);
        App.camera.position.set(5, 0, 0);
        App.camera.lookAt(0, 0, 0);
        App.camera.up = new THREE.Vector3(0, 0, 1);
        //App.camera.setRotationFromEuler(new THREE.Euler(0,0.0,0.0,'XYZ'))
        return App.camera;
      }

      topView() {
        boundMethodCheck(this, ref3);
        App.camera.position.set(0, 0, 5);
        App.camera.lookAt(0, 0, 0);
        App.camera.up = new THREE.Vector3(1, 0, 0);
        return App.camera;
      }

      sideView() {
        boundMethodCheck(this, ref3);
        App.camera.position.set(0, 5, 0);
        App.camera.lookAt(0, 0, 0);
        App.camera.up = new THREE.Vector3(0, 0, 1);
        return App.camera;
      }

    };

    RobotForm.prototype.el = $("#controldiv");

    RobotForm.prototype.events = {
      "click #loadbutton": "resetNload",
      "click #screenshot": "showScreenshot",
      "drop #robottextbox": "URDFfiledrop",
      "drag #robottextbox": "URDFfiledrag",
      "click #screenshotplace": "closeScreenshot",
      "click #frontview": "frontView",
      "click #topview": "topView",
      "click #sideview": "sideView",
      "click #saverobot": "saveRobot",
      "click #armode": "arMode",
      "change #visible": "visible"
    };

    return RobotForm;

  }).call(this);

  // Helper clock, I have just added zerotime - to be able to have
  App.Clock = class Clock extends THREE.Clock { //just adding zerotime - we can manipulate thing that was called oldtime so that get elapsedTime can be non zero at the beginning
    constructor(autostart, zeroTime) {
      super(autostart);
      this.zeroTime = zeroTime != null ? zeroTime : 0;
    }

    start(zerotime) {
      super.start(); //XXX it is running but we still play with it ?
      this.zeroTime = zerotime != null ? zerotime : this.zeroTime;
      this.oldTime = this.oldTime - this.zeroTime;
      return this;
    }

    stop() { //I like chaining , btw stop is essentially a pause?
      super.stop();
      return this;
    }

    reset() { //because stop just pauses
      this.stop().elapsedTime = 0;
      return this;
    }

    set(timeinsec) { //"sets the clock" -
      this.zerotime = timeinsec;
      this.elapsedTime = timeinsec;
      return this;
    }

  };

  App.TrajectoryView = (function() {
    // This watches over trajectory generation
    class TrajectoryView extends Backbone.View {
      initialize() {
        this.tracing = false;
        return this.robot_trajectory = new App.RobotTrajectory("Nothing");
      }

      //@create_list()
      create_list() {
        $("#all_links").empty();
        window.robotlinkcollection.each(function(link) {
          var linkname;
          linkname = link.get("name");
          return $("#all_links").append(new Option(linkname, linkname));
        });
        //console.log(linkname)
        this.tracing = false;
        $("#tracebutton").removeClass("btn-danger").addClass("btn-success");
        this.clear;
        return true;
      }

      clear() {
        console.log("clearing");
        return this.robot_trajectory.clear_trajectory();
      }

      trace() {
        var name;
        console.log("tracing");
        if (!this.tracing) {
          //name=$("#link_name_form").val()
          name = $("#all_links").val();
          if ((name != null) && name !== "") {
            this.robot_trajectory.new_name(name);
            this.tracing = true;
            $("#tracebutton").removeClass("btn-success").addClass("btn-danger");
          }
        } else {
          this.tracing = false;
          $("#tracebutton").removeClass("btn-danger").addClass("btn-success");
        }
        return true;
      }

      update() {
        //@robot_trajectory.add_to_trajectory()
        if (this.tracing) {
          this.robot_trajectory.throttled_add_to_trajectory();
        }
        return true;
      }

    };

    TrajectoryView.prototype.el = $("#trajectory");

    TrajectoryView.prototype.events = {
      "click #tracebutton": "trace",
      "click #clear_trajectory": "clear"
    };

    return TrajectoryView;

  }).call(this);

  // AnimationForm class will control robot animation, from the form submission, in different modes
  // * play: plays through poses set in @poses with points in time set in @times array
  // * pause: stops playing
  // * stop: stops and resets
  // * step: goes through @poses
  ref4 = App.AnimationForm = (function() {
    class AnimationForm extends Backbone.View {
      constructor() {
        super(...arguments);
        this.CSVfiledrag = this.CSVfiledrag.bind(this);
        this.CSVfiledrop = this.CSVfiledrop.bind(this);
        this.loadCSVfromForm = this.loadCSVfromForm.bind(this);
        this.prettify = this.prettify.bind(this);
        // Helper function that prepares 3 arrays from comma seperated values string. Times can be explicetely stated in first column, if not, it will create array of times with deltaTime timestep
        this.prepareArraysfromCSV = this.prepareArraysfromCSV.bind(this);
        this.findframetoshow = this.findframetoshow.bind(this);
        this.play = this.play.bind(this);
        this.stop = this.stop.bind(this);
        this.pause = this.pause.bind(this);
        this.update = this.update.bind(this);
        this.settostaticframe = this.settostaticframe.bind(this);
        this.nextstep = this.nextstep.bind(this);
        this.prevstep = this.prevstep.bind(this);
      }

      initialize() {
        //console.log("intialize robotjointmanipsingle");
        this.curtime = new App.Clock(false); // init timer without autostart
        this.robotcontroller = this.options.robotcontroller;
        this.zerotime = 0; // it will be used when pousing, stepping
        this.state = "stopped";
        this.textform = $("#robotcsv");
        this.lh = 18;
        this.line_height_value = "" + this.lh + "px";
        return this.textform.css("line-height", this.line_height_value);
      }

      CSVfiledrag(evt) {
        boundMethodCheck(this, ref4);
        evt.stopPropagation();
        evt.preventDefault();
        return evt.originalEvent.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
      }

      CSVfiledrop(evt) {
        var f, files, j, len1, output, reader, results;
        boundMethodCheck(this, ref4);
        window.evt = evt;
        console.log(evt);
        evt.stopPropagation();
        evt.preventDefault();
        files = evt.originalEvent.dataTransfer.files;
        output = [];
        reader = new FileReader();
        reader.onload = (event) => {
          $("#robotcsv").val(event.target.result);
          return this.loadCSVfromForm();
        };
        results = [];
        for (j = 0, len1 = files.length; j < len1; j++) {
          f = files[j];
          results.push(reader.readAsText(f));
        }
        return results;
      }

      saverobot() {
        return document.getElementById("robotform").submit();
      }

      addposition() { //it assumes that current csv is loaded
        var addtime, currentstate;
        currentstate = this.robotcontroller.jointsval(this.names);
        if (this.names.length === 0) {
          this.textform.val("time," + currentstate[1] + "\n" + "0.0," + currentstate[0]);
          //there always will be time;
          this.hastimes = true;
        } else {
          addtime = "";
          if (this.hastimes) { //there are explicit times
            addtime += (this.deltaTime + parseFloat(_.last(this.times))) + ",";
          }
          //sanity check if it is all numbers
          this.textform.val(this.textform.val() + addtime + currentstate[0]);
        }
        //@textform.append("\n"+currentstate[0])
        return this.loadCSVfromForm();
      }

      playbutton() {
        if (this.state === "finished") {
          this.stop(); //rewind
        }
        this.state = "playing";
        this.curtime.start();
        return this.play();
      }

      stopbutton() {
        this.state = "stopped";
        this.stop();
        return this.robotcontroller.changepose(this.poses[0], this.names); //full rewind
      }

      pausebutton() {
        this.state = "paused";
        return this.pause();
      }

      pp(e) {
        //console.log("eneter")
        e.stopPropagation();
        return this;
      }

      loadCSVfromForm() {
        var formcsv;
        boundMethodCheck(this, ref4);
        console.log("loading csv");
        formcsv = this.textform.val();
        formcsv = $.trim(formcsv);
        //console.log(formcsv)
        this.prepareArraysfromCSV(formcsv);
        this.textform.val(formcsv + "\n");
        return this;
      }

      prettify() {
        boundMethodCheck(this, ref4);
        this.textform.scrollTop(this.lh * (this.curframe + 1));
        if (this.curframe > 0) {
          $("#jointnames").text(this.names + "");
        } else {
          $("#jointnames").text(".");
        }
        return this;
      }

      prepareArraysfromCSV(csvstring) {
        var allfromcsv, body, head, lastn;
        boundMethodCheck(this, ref4);
        //clear all as this can be users intention
        this.names = [];
        this.poses = [];
        this.times = [];
        //csvstring=$.trim()
        allfromcsv = CSVToArray(csvstring); //I use some CSVToArray function found on web
        
        //console.log(allfromcsv)
        if (allfromcsv.length < 2) {
          console.log("It should have at least names and one pose row");
          return false;
        }
        //from here, we devide in 3 arrays: names, times, poses
        head = allfromcsv[0];
        body = allfromcsv.slice(1);
        this.hastimes = head[0] === "time";
        //console.log(hastimes)
        if (this.hastimes) { //there is explicitely set array of times
          this.names = _.rest(head);
          body = _.sortBy(body, function(element) {
            return parseFloat(_.first(element));
          });
          //making sure times are growing (sortinig)
          _.each(body, function(element) {
            this.times.push(parseFloat(_.first(element)));
            return this.poses.push(_.rest(element));
          }, this);
        } else {
          this.names = head;
          _.each(body, function(element) {
            return this.poses.push(element);
          }, this);
          lastn = this.poses.length;
          this.times = _.range(0, lastn); //range sucks with floating point
          this.times = _.map(this.times, function(time) {
            return time * this.deltaTime;
          }, this); //to step each DetltaTime
        }
        return this;
      }

      findframetoshow(currtime) { //we assume that frames are sorted by time (it is done in prepareArraysFromCSV)
        var frame;
        boundMethodCheck(this, ref4);
        frame = this.curframe;
        while ((frame <= this.times.length) && (this.times[frame + 1] < currtime)) {
          frame += 1;
        }
        //thinking whether to change @currframe here
        return frame;
      }

      play() {
        var currtime, pose;
        boundMethodCheck(this, ref4);
        //if @curtime.running
        currtime = this.curtime.getElapsedTime();
        //console.log(currtime)
        this.curframe = this.findframetoshow(currtime);
        //App.notsofast(@curframe)
        //console.log(@currframe)
        pose = this.poses[this.curframe];
        //console.log(pose)
        if (this.curframe >= (this.times.length - 1)) { //shouldn't ever be bigger
          //console.log("fin")
          //@stop()
          this.state = "finished";
        }
        if (pose !== this.pose) { //don't calculate when there is no need
          this.robotcontroller.changepose(pose, this.names);
        }
        //console.log(pose)
        //else:
        //    console.log("same")
        this.pose = pose;
        this.prettify();
        return this;
      }

      stop() {
        boundMethodCheck(this, ref4);
        this.savetime = 0; //it will restart with curtime =0
        this.curframe = 0; //rewind
        this.curtime.reset();
        this.state = "stopped";
        this.prettify();
        return this;
      }

      pause() {
        boundMethodCheck(this, ref4);
        this.savetime = this.curtime.getElapsedTime(); //it will restart with curtime =savetime
        this.curtime.stop();
        this.state = "paused";
        return this;
      }

      update() { //this will be updated at each render frame (it has to be put at render)
        boundMethodCheck(this, ref4);
        if (this.state === "playing") {
          //App.notsofast("updating")
          this.play();
        }
        return this;
      }

      settostaticframe(framenum) {
        var pose;
        boundMethodCheck(this, ref4);
        pose = this.poses[framenum];
        this.robotcontroller.changepose(pose, this.names);
        this.curframe = framenum;
        this.curtime.set(this.times[framenum]);
        return this;
      }

      nextstep() {
        var testframe;
        boundMethodCheck(this, ref4);
        this.state = "stepmode";
        testframe = this.curframe + 1;
        if (testframe >= this.times.length) {

        } else {
          //last one was last ;)
          this.settostaticframe(testframe);
        }
        return this.prettify();
      }

      prevstep() {
        var testframe;
        boundMethodCheck(this, ref4);
        this.state = "stepmode";
        testframe = this.curframe - 1;
        if (testframe < 0) {

        } else {
          //we have come to beginning TODO maybie rewind?
          this.settostaticframe(testframe);
        }
        return this.prettify();
      }

    };

    AnimationForm.prototype.el = $("#animdiv");

    AnimationForm.prototype.names = [];

    AnimationForm.prototype.poses = [];

    AnimationForm.prototype.times = [];

    AnimationForm.prototype.deltaTime = 0.06;

    AnimationForm.prototype.curframe = 0;

    AnimationForm.prototype.hastimes = false;

    AnimationForm.prototype.events = {
      "click #loadcsv": "loadCSVfromForm",
      "drop #robotcsv": "CSVfiledrop",
      "drag #robotcsv": "CSVfiledrag",
      "keydown #robotcsv": "pp",
      "click #playbutton": "playbutton",
      "click #pausebutton": "pausebutton",
      "click #stopbutton": "stopbutton",
      "click #nextbutton": "nextstep",
      "click #prevbutton": "prevstep",
      "click #addposition": "addposition",
      "click #save": "saverobot"
    };

    return AnimationForm;

  }).call(this);

  // Just a small helper to show what is with animation
  App.notsofast = _.throttle(function(tekkx) {
    console.log(tekkx);
    return true;
  }, 1000);

  //App.notsofast("fufu")

}).call(this);
