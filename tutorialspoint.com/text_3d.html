<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="ie=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Three.js - 3d text</title>
      <style>
         /* Reset and base styling */
         * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -applesystem, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,
               Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
         }
         html,
         body {
            height: 100vh;
            width: 100vw;
         }
         /* Container for three.js canvas */
         #threejs-container {
            position: block;
            width: 100%;
            height: 100%;
         }
      </style>
      <!-- Import Three.js and dat.GUI -->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.js"></script>
   <head>
   <body>
      <div id="threejs-container"></div>
      <script type="module">
         // ---------------------------------------------
         // Creating 3D text using TextGeometry
         // ---------------------------------------------

         // GUI setup for interactive controls
         const gui = new dat.GUI()

         // Initial screen sizes
         let width = window.innerWidth
         let height = window.innerHeight

         // Scene
         const scene = new THREE.Scene()
         scene.background = new THREE.Color(0x262626) // dark gray background

         // Lighting: ambient + point light for shadows and highlights
         const ambientLight = new THREE.AmbientLight(0xffffff, 1)
         scene.add(ambientLight)

         const pointLight = new THREE.PointLight(0xffffff, 0.5)
         pointLight.position.set(20, 30, 40)
         scene.add(pointLight)

         // Camera setup
         const camera = new THREE.PerspectiveCamera(30, width / height, 0.1, 1000)
         camera.position.set(0, 0, 50)

         // GUI control for camera Z movement
         const camFolder = gui.addFolder('Camera')
         camFolder.add(camera.position, 'z').min(10).max(500).step(10)
         camFolder.open()

         // Font loader
         const loader = new THREE.FontLoader()

         // Helper: wrap font loading in a Promise for async/await
         function loadFont(url) {
            return new Promise((resolve, reject) => {
               loader.load(url, resolve, undefined, reject)
            })
         }

         // Async function to load font and create 3D text
         async function doit() {
            // Load font JSON from Three.js examples
            const font = await loadFont('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json')

            // Text string to render
            let text = 'Hello World !'

            // Create text geometry with bevel for depth
            const geometry = new THREE.TextGeometry(text, {
               font: font,
               size: 3,
               height: 0.2,
               curveSegments: 12,
               bevelEnabled: true,
               bevelOffset: 0,
               bevelThickness: 0.5,
               bevelSize: 0.3,
               bevelSegments: 5
            })

            // Materials: front (pink) and sides (yellow)
            const material = [
               new THREE.MeshPhongMaterial({
                  color: 0xff22cc,
                  flatShading: true
               }),
               new THREE.MeshPhongMaterial({
                  color: 0xffcc22
               })
            ]

            // Create mesh from geometry + material
            const mesh = new THREE.Mesh(geometry, material)

            // Center the text using its bounding box
            geometry.computeBoundingBox()
            geometry.computeVertexNormals()
            geometry.boundingBox.getCenter(mesh.position).multiplyScalar(-1)
            mesh.position.x = -geometry.boundingBox.max.x / 2

            // Wrap inside an Object3D for easy grouping
            const parent = new THREE.Object3D()
            parent.add(mesh)
            scene.add(parent)

            // Extract geometry options for live editing in GUI
            const opts = geometry.parameters.options
            const geoProps = {
               font: opts.font,
               size: opts.size,
               height: opts.height,
               curveSegments: opts.curveSegments,
               bevelEnabled: opts.bevelEnabled,
               bevelOffset: opts.bevelOffset,
               bevelThickness: opts.bevelThickness,
               bevelSize: opts.bevelSize,
               bevelSegments: opts.bevelSegments
            }

            // GUI controls to experiment with geometry properties
            const props = gui.addFolder('Properties')
            props.add(geoProps, 'size', 1, 30).step(1).onChange(redraw)
            props.add(geoProps, 'height', 0, 30).step(0.1).onChange(redraw)
            props.add(geoProps, 'curveSegments', 1, 30).step(1).onChange(redraw)
            props.add(geoProps, 'bevelEnabled').onChange(redraw)
            props.add(geoProps, 'bevelOffset', 0, 1).onChange(redraw)
            props.add(geoProps, 'bevelThickness', 0, 3).onChange(redraw)
            props.add(geoProps, 'bevelSize', 0, 3).onChange(redraw)
            props.add(geoProps, 'bevelSegments', 1, 8).step(1).onChange(redraw)
            props.open()

            // Function to regenerate geometry when GUI values change
            function redraw() {
               camera.position.set(0, 0, 80) // zoom out for better view
               let newGeometry = new THREE.TextGeometry(text, {
                  font: geoProps.font,
                  size: geoProps.size,
                  height: geoProps.height,
                  curveSegments: geoProps.curveSegments,
                  bevelEnabled: geoProps.bevelEnabled,
                  bevelOffset: geoProps.bevelOffset,
                  bevelThickness: geoProps.bevelThickness,
                  bevelSize: geoProps.bevelSize,
                  bevelSegments: geoProps.bevelSegments
               })
               mesh.geometry.dispose() // dispose old geometry
               mesh.geometry = newGeometry
               mesh.geometry.parameters.options.depth = 0.2 // force a depth property
            }
         }

         // Run async function to create the text
         doit()

         // ---------------------------------------------
         // Handle window resize
         // ---------------------------------------------
         window.addEventListener('resize', () => {
            width = window.innerWidth
            height = window.innerHeight
            camera.aspect = width / height
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
            renderer.render(scene, camera)
         })

         // Renderer setup
         const renderer = new THREE.WebGL1Renderer({ antialias: true })
         renderer.setSize(width, height)
         renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

         // Animation loop
         function animate() {
            requestAnimationFrame(animate)
            renderer.render(scene, camera)
         }

         // Attach renderer to DOM and start rendering
         const container = document.querySelector('#threejs-container')
         container.append(renderer.domElement)
         renderer.render(scene, camera)
         animate()
      </script>
   </body>
</html>
